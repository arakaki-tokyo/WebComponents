(() => { var e = { 84: function (e) { e.exports = function () { "use strict"; function e(e, t) { for (var n = 0; n < t.length; n++) { var u = t[n]; u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(e, u.key, u) } } function t(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, u = new Array(t); n < t; n++)u[n] = e[n]; return u } function n(e, n) { var u = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]; if (u) return (u = u.call(e)).next.bind(u); if (Array.isArray(e) || (u = function (e, n) { if (e) { if ("string" == typeof e) return t(e, n); var u = Object.prototype.toString.call(e).slice(8, -1); return "Object" === u && e.constructor && (u = e.constructor.name), "Map" === u || "Set" === u ? Array.from(e) : "Arguments" === u || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u) ? t(e, n) : void 0 } }(e)) || n && e && "number" == typeof e.length) { u && (e = u); var r = 0; return function () { return r >= e.length ? { done: !0 } : { done: !1, value: e[r++] } } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var u = { exports: {} }; function r() { return { baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartLists: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 } } u.exports = { defaults: { baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartLists: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 }, getDefaults: r, changeDefaults: function (e) { u.exports.defaults = e } }; var i = /[&<>"']/, s = /[&<>"']/g, a = /[<>"']|&(?!#?\w+;)/, o = /[<>"']|&(?!#?\w+;)/g, l = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, c = function (e) { return l[e] }; var h = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi; function D(e) { return e.replace(h, (function (e, t) { return "colon" === (t = t.toLowerCase()) ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : "" })) } var g = /(^|[^\[])\^/g; var p = /[^\w:]/g, d = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i; var f = {}, b = /^[^:]+:\/*[^/]*$/, A = /^([^:]+:)[\s\S]*$/, E = /^([^:]+:\/*[^/]*)[\s\S]*$/; function x(e, t) { f[" " + e] || (b.test(e) ? f[" " + e] = e + "/" : f[" " + e] = m(e, "/", !0)); var n = -1 === (e = f[" " + e]).indexOf(":"); return "//" === t.substring(0, 2) ? n ? t : e.replace(A, "$1") + t : "/" === t.charAt(0) ? n ? t : e.replace(E, "$1") + t : e + t } function m(e, t, n) { var u = e.length; if (0 === u) return ""; for (var r = 0; r < u;) { var i = e.charAt(u - r - 1); if (i !== t || n) { if (i === t || !n) break; r++ } else r++ } return e.substr(0, u - r) } var k = function (e, t) { if (t) { if (i.test(e)) return e.replace(s, c) } else if (a.test(e)) return e.replace(o, c); return e }, F = D, C = function (e, t) { e = e.source || e, t = t || ""; var n = { replace: function (t, u) { return u = (u = u.source || u).replace(g, "$1"), e = e.replace(t, u), n }, getRegex: function () { return new RegExp(e, t) } }; return n }, w = function (e, t, n) { if (e) { var u; try { u = decodeURIComponent(D(n)).replace(p, "").toLowerCase() } catch (e) { return null } if (0 === u.indexOf("javascript:") || 0 === u.indexOf("vbscript:") || 0 === u.indexOf("data:")) return null } t && !d.test(n) && (n = x(t, n)); try { n = encodeURI(n).replace(/%25/g, "%") } catch (e) { return null } return n }, B = { exec: function () { } }, v = function (e) { for (var t, n, u = 1; u < arguments.length; u++)for (n in t = arguments[u]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, y = function (e, t) { var n = e.replace(/\|/g, (function (e, t, n) { for (var u = !1, r = t; --r >= 0 && "\\" === n[r];)u = !u; return u ? "|" : " |" })).split(/ \|/), u = 0; if (n[0].trim() || n.shift(), n[n.length - 1].trim() || n.pop(), n.length > t) n.splice(t); else for (; n.length < t;)n.push(""); for (; u < n.length; u++)n[u] = n[u].trim().replace(/\\\|/g, "|"); return n }, _ = m, S = function (e, t) { if (-1 === e.indexOf(t[1])) return -1; for (var n = e.length, u = 0, r = 0; r < n; r++)if ("\\" === e[r]) r++; else if (e[r] === t[0]) u++; else if (e[r] === t[1] && --u < 0) return r; return -1 }, R = function (e) { e && e.sanitize && !e.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options") }, z = function (e, t) { if (t < 1) return ""; for (var n = ""; t > 1;)1 & t && (n += e), t >>= 1, e += e; return n + e }, $ = u.exports.defaults, O = _, T = y, I = k, N = S; function j(e, t, n, u) { var r = t.href, i = t.title ? I(t.title) : null, s = e[1].replace(/\\([\[\]])/g, "$1"); if ("!" !== e[0].charAt(0)) { u.state.inLink = !0; var a = { type: "link", raw: n, href: r, title: i, text: s, tokens: u.inlineTokens(s, []) }; return u.state.inLink = !1, a } return { type: "image", raw: n, href: r, title: i, text: I(s) } } var M = function () { function e(e) { this.options = e || $ } var t = e.prototype; return t.space = function (e) { var t = this.rules.block.newline.exec(e); if (t) return t[0].length > 1 ? { type: "space", raw: t[0] } : { raw: "\n" } }, t.code = function (e) { var t = this.rules.block.code.exec(e); if (t) { var n = t[0].replace(/^ {1,4}/gm, ""); return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : O(n, "\n") } } }, t.fences = function (e) { var t = this.rules.block.fences.exec(e); if (t) { var n = t[0], u = function (e, t) { var n = e.match(/^(\s+)(?:```)/); if (null === n) return t; var u = n[1]; return t.split("\n").map((function (e) { var t = e.match(/^\s+/); return null === t ? e : t[0].length >= u.length ? e.slice(u.length) : e })).join("\n") }(n, t[3] || ""); return { type: "code", raw: n, lang: t[2] ? t[2].trim() : t[2], text: u } } }, t.heading = function (e) { var t = this.rules.block.heading.exec(e); if (t) { var n = t[2].trim(); if (/#$/.test(n)) { var u = O(n, "#"); this.options.pedantic ? n = u.trim() : u && !/ $/.test(u) || (n = u.trim()) } var r = { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: [] }; return this.lexer.inline(r.text, r.tokens), r } }, t.hr = function (e) { var t = this.rules.block.hr.exec(e); if (t) return { type: "hr", raw: t[0] } }, t.blockquote = function (e) { var t = this.rules.block.blockquote.exec(e); if (t) { var n = t[0].replace(/^ *> ?/gm, ""); return { type: "blockquote", raw: t[0], tokens: this.lexer.blockTokens(n, []), text: n } } }, t.list = function (e) { var t = this.rules.block.list.exec(e); if (t) { var n, u, r, i, s, a, o, l, c, h, D = t[1].trim(), g = D.length > 1, p = { type: "list", raw: "", ordered: g, start: g ? +D.slice(0, -1) : "", loose: !1, items: [] }; D = g ? "\\d{1,9}\\" + D.slice(-1) : "\\" + D, this.options.pedantic && (D = g ? D : "[*+-]"); for (var d = new RegExp("^( {0,3}" + D + ")((?: [^\\n]*| *)(?:\\n[^\\n]*)*(?:\\n|$))"); e && !this.rules.block.hr.test(e) && (t = d.exec(e));) { c = t[2].split("\n"), this.options.pedantic ? (i = 2, h = c[0].trimLeft()) : (i = t[2].search(/[^ ]/), i = t[1].length + (i > 4 ? 1 : i), h = c[0].slice(i - t[1].length)), a = !1, n = t[0], !c[0] && /^ *$/.test(c[1]) && (n = t[1] + c.slice(0, 2).join("\n") + "\n", p.loose = !0, c = []); var f = new RegExp("^ {0," + Math.min(3, i - 1) + "}(?:[*+-]|\\d{1,9}[.)])"); for (s = 1; s < c.length; s++) { if (l = c[s], this.options.pedantic && (l = l.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), f.test(l)) { n = t[1] + c.slice(0, s).join("\n") + "\n"; break } if (a) { if (!(l.search(/[^ ]/) >= i) && l.trim()) { n = t[1] + c.slice(0, s).join("\n") + "\n"; break } h += "\n" + l.slice(i) } else l.trim() || (a = !0), l.search(/[^ ]/) >= i ? h += "\n" + l.slice(i) : h += "\n" + l } p.loose || (o ? p.loose = !0 : /\n *\n *$/.test(n) && (o = !0)), this.options.gfm && (u = /^\[[ xX]\] /.exec(h)) && (r = "[ ] " !== u[0], h = h.replace(/^\[[ xX]\] +/, "")), p.items.push({ type: "list_item", raw: n, task: !!u, checked: r, loose: !1, text: h }), p.raw += n, e = e.slice(n.length) } p.items[p.items.length - 1].raw = n.trimRight(), p.items[p.items.length - 1].text = h.trimRight(), p.raw = p.raw.trimRight(); var b = p.items.length; for (s = 0; s < b; s++)this.lexer.state.top = !1, p.items[s].tokens = this.lexer.blockTokens(p.items[s].text, []), p.items[s].tokens.some((function (e) { return "space" === e.type })) && (p.loose = !0, p.items[s].loose = !0); return p } }, t.html = function (e) { var t = this.rules.block.html.exec(e); if (t) { var n = { type: "html", raw: t[0], pre: !this.options.sanitizer && ("pre" === t[1] || "script" === t[1] || "style" === t[1]), text: t[0] }; return this.options.sanitize && (n.type = "paragraph", n.text = this.options.sanitizer ? this.options.sanitizer(t[0]) : I(t[0]), n.tokens = [], this.lexer.inline(n.text, n.tokens)), n } }, t.def = function (e) { var t = this.rules.block.def.exec(e); if (t) return t[3] && (t[3] = t[3].substring(1, t[3].length - 1)), { type: "def", tag: t[1].toLowerCase().replace(/\s+/g, " "), raw: t[0], href: t[2], title: t[3] } }, t.table = function (e) { var t = this.rules.block.table.exec(e); if (t) { var n = { type: "table", header: T(t[1]).map((function (e) { return { text: e } })), align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: t[3] ? t[3].replace(/\n$/, "").split("\n") : [] }; if (n.header.length === n.align.length) { n.raw = t[0]; var u, r, i, s, a = n.align.length; for (u = 0; u < a; u++)/^ *-+: *$/.test(n.align[u]) ? n.align[u] = "right" : /^ *:-+: *$/.test(n.align[u]) ? n.align[u] = "center" : /^ *:-+ *$/.test(n.align[u]) ? n.align[u] = "left" : n.align[u] = null; for (a = n.rows.length, u = 0; u < a; u++)n.rows[u] = T(n.rows[u], n.header.length).map((function (e) { return { text: e } })); for (a = n.header.length, r = 0; r < a; r++)n.header[r].tokens = [], this.lexer.inlineTokens(n.header[r].text, n.header[r].tokens); for (a = n.rows.length, r = 0; r < a; r++)for (s = n.rows[r], i = 0; i < s.length; i++)s[i].tokens = [], this.lexer.inlineTokens(s[i].text, s[i].tokens); return n } } }, t.lheading = function (e) { var t = this.rules.block.lheading.exec(e); if (t) { var n = { type: "heading", raw: t[0], depth: "=" === t[2].charAt(0) ? 1 : 2, text: t[1], tokens: [] }; return this.lexer.inline(n.text, n.tokens), n } }, t.paragraph = function (e) { var t = this.rules.block.paragraph.exec(e); if (t) { var n = { type: "paragraph", raw: t[0], text: "\n" === t[1].charAt(t[1].length - 1) ? t[1].slice(0, -1) : t[1], tokens: [] }; return this.lexer.inline(n.text, n.tokens), n } }, t.text = function (e) { var t = this.rules.block.text.exec(e); if (t) { var n = { type: "text", raw: t[0], text: t[0], tokens: [] }; return this.lexer.inline(n.text, n.tokens), n } }, t.escape = function (e) { var t = this.rules.inline.escape.exec(e); if (t) return { type: "escape", raw: t[0], text: I(t[1]) } }, t.tag = function (e) { var t = this.rules.inline.tag.exec(e); if (t) return !this.lexer.state.inLink && /^<a /i.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) && (this.lexer.state.inRawBlock = !1), { type: this.options.sanitize ? "text" : "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t[0]) : I(t[0]) : t[0] } }, t.link = function (e) { var t = this.rules.inline.link.exec(e); if (t) { var n = t[2].trim(); if (!this.options.pedantic && /^</.test(n)) { if (!/>$/.test(n)) return; var u = O(n.slice(0, -1), "\\"); if ((n.length - u.length) % 2 == 0) return } else { var r = N(t[2], "()"); if (r > -1) { var i = (0 === t[0].indexOf("!") ? 5 : 4) + t[1].length + r; t[2] = t[2].substring(0, r), t[0] = t[0].substring(0, i).trim(), t[3] = "" } } var s = t[2], a = ""; if (this.options.pedantic) { var o = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(s); o && (s = o[1], a = o[3]) } else a = t[3] ? t[3].slice(1, -1) : ""; return s = s.trim(), /^</.test(s) && (s = this.options.pedantic && !/>$/.test(n) ? s.slice(1) : s.slice(1, -1)), j(t, { href: s ? s.replace(this.rules.inline._escapes, "$1") : s, title: a ? a.replace(this.rules.inline._escapes, "$1") : a }, t[0], this.lexer) } }, t.reflink = function (e, t) { var n; if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) { var u = (n[2] || n[1]).replace(/\s+/g, " "); if (!(u = t[u.toLowerCase()]) || !u.href) { var r = n[0].charAt(0); return { type: "text", raw: r, text: r } } return j(n, u, n[0], this.lexer) } }, t.emStrong = function (e, t, n) { void 0 === n && (n = ""); var u = this.rules.inline.emStrong.lDelim.exec(e); if (u && (!u[3] || !n.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))) { var r = u[1] || u[2] || ""; if (!r || r && ("" === n || this.rules.inline.punctuation.exec(n))) { var i, s, a = u[0].length - 1, o = a, l = 0, c = "*" === u[0][0] ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd; for (c.lastIndex = 0, t = t.slice(-1 * e.length + a); null != (u = c.exec(t));)if (i = u[1] || u[2] || u[3] || u[4] || u[5] || u[6]) if (s = i.length, u[3] || u[4]) o += s; else if (!((u[5] || u[6]) && a % 3) || (a + s) % 3) { if (!((o -= s) > 0)) { if (s = Math.min(s, s + o + l), Math.min(a, s) % 2) { var h = e.slice(1, a + u.index + s); return { type: "em", raw: e.slice(0, a + u.index + s + 1), text: h, tokens: this.lexer.inlineTokens(h, []) } } var D = e.slice(2, a + u.index + s - 1); return { type: "strong", raw: e.slice(0, a + u.index + s + 1), text: D, tokens: this.lexer.inlineTokens(D, []) } } } else l += s } } }, t.codespan = function (e) { var t = this.rules.inline.code.exec(e); if (t) { var n = t[2].replace(/\n/g, " "), u = /[^ ]/.test(n), r = /^ /.test(n) && / $/.test(n); return u && r && (n = n.substring(1, n.length - 1)), n = I(n, !0), { type: "codespan", raw: t[0], text: n } } }, t.br = function (e) { var t = this.rules.inline.br.exec(e); if (t) return { type: "br", raw: t[0] } }, t.del = function (e) { var t = this.rules.inline.del.exec(e); if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2], []) } }, t.autolink = function (e, t) { var n, u, r = this.rules.inline.autolink.exec(e); if (r) return u = "@" === r[2] ? "mailto:" + (n = I(this.options.mangle ? t(r[1]) : r[1])) : n = I(r[1]), { type: "link", raw: r[0], text: n, href: u, tokens: [{ type: "text", raw: n, text: n }] } }, t.url = function (e, t) { var n; if (n = this.rules.inline.url.exec(e)) { var u, r; if ("@" === n[2]) r = "mailto:" + (u = I(this.options.mangle ? t(n[0]) : n[0])); else { var i; do { i = n[0], n[0] = this.rules.inline._backpedal.exec(n[0])[0] } while (i !== n[0]); u = I(n[0]), r = "www." === n[1] ? "http://" + u : u } return { type: "link", raw: n[0], text: u, href: r, tokens: [{ type: "text", raw: u, text: u }] } } }, t.inlineText = function (e, t) { var n, u = this.rules.inline.text.exec(e); if (u) return n = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(u[0]) : I(u[0]) : u[0] : I(this.options.smartypants ? t(u[0]) : u[0]), { type: "text", raw: u[0], text: n } }, e }(), L = B, P = C, Z = v, U = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/, table: L, lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ }; U.def = P(U.def).replace("label", U._label).replace("title", U._title).getRegex(), U.bullet = /(?:[*+-]|\d{1,9}[.)])/, U.listItemStart = P(/^( *)(bull) */).replace("bull", U.bullet).getRegex(), U.list = P(U.list).replace(/bull/g, U.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + U.def.source + ")").getRegex(), U._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", U._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, U.html = P(U.html, "i").replace("comment", U._comment).replace("tag", U._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), U.paragraph = P(U._paragraph).replace("hr", U.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", U._tag).getRegex(), U.blockquote = P(U.blockquote).replace("paragraph", U.paragraph).getRegex(), U.normal = Z({}, U), U.gfm = Z({}, U.normal, { table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }), U.gfm.table = P(U.gfm.table).replace("hr", U.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", U._tag).getRegex(), U.pedantic = Z({}, U.normal, { html: P("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", U._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: L, paragraph: P(U.normal._paragraph).replace("hr", U.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", U.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() }); var H = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: L, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/, nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/, rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: L, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/, _punctuation: "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~" }; H.punctuation = P(H.punctuation).replace(/punctuation/g, H._punctuation).getRegex(), H.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, H.escapedEmSt = /\\\*|\\_/g, H._comment = P(U._comment).replace("(?:--\x3e|$)", "--\x3e").getRegex(), H.emStrong.lDelim = P(H.emStrong.lDelim).replace(/punct/g, H._punctuation).getRegex(), H.emStrong.rDelimAst = P(H.emStrong.rDelimAst, "g").replace(/punct/g, H._punctuation).getRegex(), H.emStrong.rDelimUnd = P(H.emStrong.rDelimUnd, "g").replace(/punct/g, H._punctuation).getRegex(), H._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, H._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, H._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, H.autolink = P(H.autolink).replace("scheme", H._scheme).replace("email", H._email).getRegex(), H._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, H.tag = P(H.tag).replace("comment", H._comment).replace("attribute", H._attribute).getRegex(), H._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, H._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, H._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, H.link = P(H.link).replace("label", H._label).replace("href", H._href).replace("title", H._title).getRegex(), H.reflink = P(H.reflink).replace("label", H._label).getRegex(), H.reflinkSearch = P(H.reflinkSearch, "g").replace("reflink", H.reflink).replace("nolink", H.nolink).getRegex(), H.normal = Z({}, H), H.pedantic = Z({}, H.normal, { strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: P(/^!?\[(label)\]\((.*?)\)/).replace("label", H._label).getRegex(), reflink: P(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", H._label).getRegex() }), H.gfm = Z({}, H.normal, { escape: P(H.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }), H.gfm.url = P(H.gfm.url, "i").replace("email", H.gfm._extended_email).getRegex(), H.breaks = Z({}, H.gfm, { br: P(H.br).replace("{2,}", "*").getRegex(), text: P(H.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }); var q = { block: U, inline: H }, K = M, X = u.exports.defaults, G = q.block, Q = q.inline, W = z; function J(e) { return e.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…") } function V(e) { var t, n, u = "", r = e.length; for (t = 0; t < r; t++)n = e.charCodeAt(t), Math.random() > .5 && (n = "x" + n.toString(16)), u += "&#" + n + ";"; return u } var Y = function () { function t(e) { this.tokens = [], this.tokens.links = Object.create(null), this.options = e || X, this.options.tokenizer = this.options.tokenizer || new K, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 }; var t = { block: G.normal, inline: Q.normal }; this.options.pedantic ? (t.block = G.pedantic, t.inline = Q.pedantic) : this.options.gfm && (t.block = G.gfm, this.options.breaks ? t.inline = Q.breaks : t.inline = Q.gfm), this.tokenizer.rules = t } t.lex = function (e, n) { return new t(n).lex(e) }, t.lexInline = function (e, n) { return new t(n).inlineTokens(e) }; var n, u, r, i = t.prototype; return i.lex = function (e) { var t; for (e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    "), this.blockTokens(e, this.tokens); t = this.inlineQueue.shift();)this.inlineTokens(t.src, t.tokens); return this.tokens }, i.blockTokens = function (e, t) { var n, u, r, i, s = this; for (void 0 === t && (t = []), this.options.pedantic && (e = e.replace(/^ +$/gm, "")); e;)if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((function (u) { return !!(n = u.call({ lexer: s }, e, t)) && (e = e.substring(n.raw.length), t.push(n), !0) })))) if (n = this.tokenizer.space(e)) e = e.substring(n.raw.length), n.type && t.push(n); else if (n = this.tokenizer.code(e)) e = e.substring(n.raw.length), !(u = t[t.length - 1]) || "paragraph" !== u.type && "text" !== u.type ? t.push(n) : (u.raw += "\n" + n.raw, u.text += "\n" + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = u.text); else if (n = this.tokenizer.fences(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.heading(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.hr(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.blockquote(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.list(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.html(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.def(e)) e = e.substring(n.raw.length), !(u = t[t.length - 1]) || "paragraph" !== u.type && "text" !== u.type ? this.tokens.links[n.tag] || (this.tokens.links[n.tag] = { href: n.href, title: n.title }) : (u.raw += "\n" + n.raw, u.text += "\n" + n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = u.text); else if (n = this.tokenizer.table(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.lheading(e)) e = e.substring(n.raw.length), t.push(n); else if (r = e, this.options.extensions && this.options.extensions.startBlock && function () { var t = 1 / 0, n = e.slice(1), u = void 0; s.options.extensions.startBlock.forEach((function (e) { "number" == typeof (u = e.call({ lexer: this }, n)) && u >= 0 && (t = Math.min(t, u)) })), t < 1 / 0 && t >= 0 && (r = e.substring(0, t + 1)) }(), this.state.top && (n = this.tokenizer.paragraph(r))) u = t[t.length - 1], i && "paragraph" === u.type ? (u.raw += "\n" + n.raw, u.text += "\n" + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = u.text) : t.push(n), i = r.length !== e.length, e = e.substring(n.raw.length); else if (n = this.tokenizer.text(e)) e = e.substring(n.raw.length), (u = t[t.length - 1]) && "text" === u.type ? (u.raw += "\n" + n.raw, u.text += "\n" + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = u.text) : t.push(n); else if (e) { var a = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(a); break } throw new Error(a) } return this.state.top = !0, t }, i.inline = function (e, t) { this.inlineQueue.push({ src: e, tokens: t }) }, i.inlineTokens = function (e, t) { var n, u, r, i = this; void 0 === t && (t = []); var s, a, o, l = e; if (this.tokens.links) { var c = Object.keys(this.tokens.links); if (c.length > 0) for (; null != (s = this.tokenizer.rules.inline.reflinkSearch.exec(l));)c.includes(s[0].slice(s[0].lastIndexOf("[") + 1, -1)) && (l = l.slice(0, s.index) + "[" + W("a", s[0].length - 2) + "]" + l.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)) } for (; null != (s = this.tokenizer.rules.inline.blockSkip.exec(l));)l = l.slice(0, s.index) + "[" + W("a", s[0].length - 2) + "]" + l.slice(this.tokenizer.rules.inline.blockSkip.lastIndex); for (; null != (s = this.tokenizer.rules.inline.escapedEmSt.exec(l));)l = l.slice(0, s.index) + "++" + l.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex); for (; e;)if (a || (o = ""), a = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((function (u) { return !!(n = u.call({ lexer: i }, e, t)) && (e = e.substring(n.raw.length), t.push(n), !0) })))) if (n = this.tokenizer.escape(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.tag(e)) e = e.substring(n.raw.length), (u = t[t.length - 1]) && "text" === n.type && "text" === u.type ? (u.raw += n.raw, u.text += n.text) : t.push(n); else if (n = this.tokenizer.link(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.reflink(e, this.tokens.links)) e = e.substring(n.raw.length), (u = t[t.length - 1]) && "text" === n.type && "text" === u.type ? (u.raw += n.raw, u.text += n.text) : t.push(n); else if (n = this.tokenizer.emStrong(e, l, o)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.codespan(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.br(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.del(e)) e = e.substring(n.raw.length), t.push(n); else if (n = this.tokenizer.autolink(e, V)) e = e.substring(n.raw.length), t.push(n); else if (this.state.inLink || !(n = this.tokenizer.url(e, V))) { if (r = e, this.options.extensions && this.options.extensions.startInline && function () { var t = 1 / 0, n = e.slice(1), u = void 0; i.options.extensions.startInline.forEach((function (e) { "number" == typeof (u = e.call({ lexer: this }, n)) && u >= 0 && (t = Math.min(t, u)) })), t < 1 / 0 && t >= 0 && (r = e.substring(0, t + 1)) }(), n = this.tokenizer.inlineText(r, J)) e = e.substring(n.raw.length), "_" !== n.raw.slice(-1) && (o = n.raw.slice(-1)), a = !0, (u = t[t.length - 1]) && "text" === u.type ? (u.raw += n.raw, u.text += n.text) : t.push(n); else if (e) { var h = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(h); break } throw new Error(h) } } else e = e.substring(n.raw.length), t.push(n); return t }, n = t, r = [{ key: "rules", get: function () { return { block: G, inline: Q } } }], (u = null) && e(n.prototype, u), r && e(n, r), t }(), ee = u.exports.defaults, te = w, ne = k, ue = function () { function e(e) { this.options = e || ee } var t = e.prototype; return t.code = function (e, t, n) { var u = (t || "").match(/\S*/)[0]; if (this.options.highlight) { var r = this.options.highlight(e, u); null != r && r !== e && (n = !0, e = r) } return e = e.replace(/\n$/, "") + "\n", u ? '<pre><code class="' + this.options.langPrefix + ne(u, !0) + '">' + (n ? e : ne(e, !0)) + "</code></pre>\n" : "<pre><code>" + (n ? e : ne(e, !0)) + "</code></pre>\n" }, t.blockquote = function (e) { return "<blockquote>\n" + e + "</blockquote>\n" }, t.html = function (e) { return e }, t.heading = function (e, t, n, u) { return this.options.headerIds ? "<h" + t + ' id="' + this.options.headerPrefix + u.slug(n) + '">' + e + "</h" + t + ">\n" : "<h" + t + ">" + e + "</h" + t + ">\n" }, t.hr = function () { return this.options.xhtml ? "<hr/>\n" : "<hr>\n" }, t.list = function (e, t, n) { var u = t ? "ol" : "ul"; return "<" + u + (t && 1 !== n ? ' start="' + n + '"' : "") + ">\n" + e + "</" + u + ">\n" }, t.listitem = function (e) { return "<li>" + e + "</li>\n" }, t.checkbox = function (e) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> " }, t.paragraph = function (e) { return "<p>" + e + "</p>\n" }, t.table = function (e, t) { return t && (t = "<tbody>" + t + "</tbody>"), "<table>\n<thead>\n" + e + "</thead>\n" + t + "</table>\n" }, t.tablerow = function (e) { return "<tr>\n" + e + "</tr>\n" }, t.tablecell = function (e, t) { var n = t.header ? "th" : "td"; return (t.align ? "<" + n + ' align="' + t.align + '">' : "<" + n + ">") + e + "</" + n + ">\n" }, t.strong = function (e) { return "<strong>" + e + "</strong>" }, t.em = function (e) { return "<em>" + e + "</em>" }, t.codespan = function (e) { return "<code>" + e + "</code>" }, t.br = function () { return this.options.xhtml ? "<br/>" : "<br>" }, t.del = function (e) { return "<del>" + e + "</del>" }, t.link = function (e, t, n) { if (null === (e = te(this.options.sanitize, this.options.baseUrl, e))) return n; var u = '<a href="' + ne(e) + '"'; return t && (u += ' title="' + t + '"'), u + ">" + n + "</a>" }, t.image = function (e, t, n) { if (null === (e = te(this.options.sanitize, this.options.baseUrl, e))) return n; var u = '<img src="' + e + '" alt="' + n + '"'; return t && (u += ' title="' + t + '"'), u + (this.options.xhtml ? "/>" : ">") }, t.text = function (e) { return e }, e }(), re = function () { function e() { } var t = e.prototype; return t.strong = function (e) { return e }, t.em = function (e) { return e }, t.codespan = function (e) { return e }, t.del = function (e) { return e }, t.html = function (e) { return e }, t.text = function (e) { return e }, t.link = function (e, t, n) { return "" + n }, t.image = function (e, t, n) { return "" + n }, t.br = function () { return "" }, e }(), ie = function () { function e() { this.seen = {} } var t = e.prototype; return t.serialize = function (e) { return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-") }, t.getNextSafeSlug = function (e, t) { var n = e, u = 0; if (this.seen.hasOwnProperty(n)) { u = this.seen[e]; do { n = e + "-" + ++u } while (this.seen.hasOwnProperty(n)) } return t || (this.seen[e] = u, this.seen[n] = 0), n }, t.slug = function (e, t) { void 0 === t && (t = {}); var n = this.serialize(e); return this.getNextSafeSlug(n, t.dryrun) }, e }(), se = ue, ae = re, oe = ie, le = u.exports.defaults, ce = F, he = function () { function e(e) { this.options = e || le, this.options.renderer = this.options.renderer || new se, this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new ae, this.slugger = new oe } e.parse = function (t, n) { return new e(n).parse(t) }, e.parseInline = function (t, n) { return new e(n).parseInline(t) }; var t = e.prototype; return t.parse = function (e, t) { void 0 === t && (t = !0); var n, u, r, i, s, a, o, l, c, h, D, g, p, d, f, b, A, E, x, m = "", k = e.length; for (n = 0; n < k; n++)if (h = e[n], !(this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[h.type]) || !1 === (x = this.options.extensions.renderers[h.type].call({ parser: this }, h)) && ["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(h.type)) switch (h.type) { case "space": continue; case "hr": m += this.renderer.hr(); continue; case "heading": m += this.renderer.heading(this.parseInline(h.tokens), h.depth, ce(this.parseInline(h.tokens, this.textRenderer)), this.slugger); continue; case "code": m += this.renderer.code(h.text, h.lang, h.escaped); continue; case "table": for (l = "", o = "", i = h.header.length, u = 0; u < i; u++)o += this.renderer.tablecell(this.parseInline(h.header[u].tokens), { header: !0, align: h.align[u] }); for (l += this.renderer.tablerow(o), c = "", i = h.rows.length, u = 0; u < i; u++) { for (o = "", s = (a = h.rows[u]).length, r = 0; r < s; r++)o += this.renderer.tablecell(this.parseInline(a[r].tokens), { header: !1, align: h.align[r] }); c += this.renderer.tablerow(o) } m += this.renderer.table(l, c); continue; case "blockquote": c = this.parse(h.tokens), m += this.renderer.blockquote(c); continue; case "list": for (D = h.ordered, g = h.start, p = h.loose, i = h.items.length, c = "", u = 0; u < i; u++)b = (f = h.items[u]).checked, A = f.task, d = "", f.task && (E = this.renderer.checkbox(b), p ? f.tokens.length > 0 && "paragraph" === f.tokens[0].type ? (f.tokens[0].text = E + " " + f.tokens[0].text, f.tokens[0].tokens && f.tokens[0].tokens.length > 0 && "text" === f.tokens[0].tokens[0].type && (f.tokens[0].tokens[0].text = E + " " + f.tokens[0].tokens[0].text)) : f.tokens.unshift({ type: "text", text: E }) : d += E), d += this.parse(f.tokens, p), c += this.renderer.listitem(d, A, b); m += this.renderer.list(c, D, g); continue; case "html": m += this.renderer.html(h.text); continue; case "paragraph": m += this.renderer.paragraph(this.parseInline(h.tokens)); continue; case "text": for (c = h.tokens ? this.parseInline(h.tokens) : h.text; n + 1 < k && "text" === e[n + 1].type;)c += "\n" + ((h = e[++n]).tokens ? this.parseInline(h.tokens) : h.text); m += t ? this.renderer.paragraph(c) : c; continue; default: var F = 'Token with "' + h.type + '" type was not found.'; if (this.options.silent) return void console.error(F); throw new Error(F) } else m += x || ""; return m }, t.parseInline = function (e, t) { t = t || this.renderer; var n, u, r, i = "", s = e.length; for (n = 0; n < s; n++)if (u = e[n], !(this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[u.type]) || !1 === (r = this.options.extensions.renderers[u.type].call({ parser: this }, u)) && ["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(u.type)) switch (u.type) { case "escape": i += t.text(u.text); break; case "html": i += t.html(u.text); break; case "link": i += t.link(u.href, u.title, this.parseInline(u.tokens, t)); break; case "image": i += t.image(u.href, u.title, u.text); break; case "strong": i += t.strong(this.parseInline(u.tokens, t)); break; case "em": i += t.em(this.parseInline(u.tokens, t)); break; case "codespan": i += t.codespan(u.text); break; case "br": i += t.br(); break; case "del": i += t.del(this.parseInline(u.tokens, t)); break; case "text": i += t.text(u.text); break; default: var a = 'Token with "' + u.type + '" type was not found.'; if (this.options.silent) return void console.error(a); throw new Error(a) } else i += r || ""; return i }, e }(), De = Y, ge = he, pe = M, de = ue, fe = re, be = ie, Ae = v, Ee = R, xe = k, me = u.exports.getDefaults, ke = u.exports.changeDefaults, Fe = u.exports.defaults; function Ce(e, t, n) { if (null == e) throw new Error("marked(): input parameter is undefined or null"); if ("string" != typeof e) throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"); if ("function" == typeof t && (n = t, t = null), t = Ae({}, Ce.defaults, t || {}), Ee(t), n) { var u, r = t.highlight; try { u = De.lex(e, t) } catch (e) { return n(e) } var i = function (e) { var i; if (!e) try { t.walkTokens && Ce.walkTokens(u, t.walkTokens), i = ge.parse(u, t) } catch (t) { e = t } return t.highlight = r, e ? n(e) : n(null, i) }; if (!r || r.length < 3) return i(); if (delete t.highlight, !u.length) return i(); var s = 0; return Ce.walkTokens(u, (function (e) { "code" === e.type && (s++, setTimeout((function () { r(e.text, e.lang, (function (t, n) { if (t) return i(t); null != n && n !== e.text && (e.text = n, e.escaped = !0), 0 == --s && i() })) }), 0)) })), void (0 === s && i()) } try { var a = De.lex(e, t); return t.walkTokens && Ce.walkTokens(a, t.walkTokens), ge.parse(a, t) } catch (e) { if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", t.silent) return "<p>An error occurred:</p><pre>" + xe(e.message + "", !0) + "</pre>"; throw e } } return Ce.options = Ce.setOptions = function (e) { return Ae(Ce.defaults, e), ke(Ce.defaults), Ce }, Ce.getDefaults = me, Ce.defaults = Fe, Ce.use = function () { for (var e = this, t = arguments.length, n = new Array(t), u = 0; u < t; u++)n[u] = arguments[u]; var r, i = Ae.apply(void 0, [{}].concat(n)), s = Ce.defaults.extensions || { renderers: {}, childTokens: {} }; n.forEach((function (t) { if (t.extensions && (r = !0, t.extensions.forEach((function (e) { if (!e.name) throw new Error("extension name required"); if (e.renderer) { var t = s.renderers ? s.renderers[e.name] : null; s.renderers[e.name] = t ? function () { for (var n = arguments.length, u = new Array(n), r = 0; r < n; r++)u[r] = arguments[r]; var i = e.renderer.apply(this, u); return !1 === i && (i = t.apply(this, u)), i } : e.renderer } if (e.tokenizer) { if (!e.level || "block" !== e.level && "inline" !== e.level) throw new Error("extension level must be 'block' or 'inline'"); s[e.level] ? s[e.level].unshift(e.tokenizer) : s[e.level] = [e.tokenizer], e.start && ("block" === e.level ? s.startBlock ? s.startBlock.push(e.start) : s.startBlock = [e.start] : "inline" === e.level && (s.startInline ? s.startInline.push(e.start) : s.startInline = [e.start])) } e.childTokens && (s.childTokens[e.name] = e.childTokens) }))), t.renderer && function () { var e = Ce.defaults.renderer || new de, n = function (n) { var u = e[n]; e[n] = function () { for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s]; var a = t.renderer[n].apply(e, i); return !1 === a && (a = u.apply(e, i)), a } }; for (var u in t.renderer) n(u); i.renderer = e }(), t.tokenizer && function () { var e = Ce.defaults.tokenizer || new pe, n = function (n) { var u = e[n]; e[n] = function () { for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s]; var a = t.tokenizer[n].apply(e, i); return !1 === a && (a = u.apply(e, i)), a } }; for (var u in t.tokenizer) n(u); i.tokenizer = e }(), t.walkTokens) { var n = Ce.defaults.walkTokens; i.walkTokens = function (u) { t.walkTokens.call(e, u), n && n(u) } } r && (i.extensions = s), Ce.setOptions(i) })) }, Ce.walkTokens = function (e, t) { for (var u, r = function () { var e = u.value; switch (t(e), e.type) { case "table": for (var r, i = n(e.header); !(r = i()).done;) { var s = r.value; Ce.walkTokens(s.tokens, t) } for (var a, o = n(e.rows); !(a = o()).done;)for (var l, c = n(a.value); !(l = c()).done;) { var h = l.value; Ce.walkTokens(h.tokens, t) } break; case "list": Ce.walkTokens(e.items, t); break; default: Ce.defaults.extensions && Ce.defaults.extensions.childTokens && Ce.defaults.extensions.childTokens[e.type] ? Ce.defaults.extensions.childTokens[e.type].forEach((function (n) { Ce.walkTokens(e[n], t) })) : e.tokens && Ce.walkTokens(e.tokens, t) } }, i = n(e); !(u = i()).done;)r() }, Ce.parseInline = function (e, t) { if (null == e) throw new Error("marked.parseInline(): input parameter is undefined or null"); if ("string" != typeof e) throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"); t = Ae({}, Ce.defaults, t || {}), Ee(t); try { var n = De.lexInline(e, t); return t.walkTokens && Ce.walkTokens(n, t.walkTokens), ge.parseInline(n, t) } catch (e) { if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", t.silent) return "<p>An error occurred:</p><pre>" + xe(e.message + "", !0) + "</pre>"; throw e } }, Ce.Parser = ge, Ce.parser = ge.parse, Ce.Renderer = de, Ce.TextRenderer = fe, Ce.Lexer = De, Ce.lexer = De.lex, Ce.Tokenizer = pe, Ce.Slugger = be, Ce.parse = Ce, Ce }() }, 390: e => { var t = { exports: {} }; function n(e) { return e instanceof Map ? e.clear = e.delete = e.set = function () { throw new Error("map is read-only") } : e instanceof Set && (e.add = e.clear = e.delete = function () { throw new Error("set is read-only") }), Object.freeze(e), Object.getOwnPropertyNames(e).forEach((function (t) { var u = e[t]; "object" != typeof u || Object.isFrozen(u) || n(u) })), e } t.exports = n, t.exports.default = n; var u = t.exports; class r { constructor(e) { void 0 === e.data && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1 } ignoreMatch() { this.isMatchIgnored = !0 } } function i(e) { return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;") } function s(e, ...t) { const n = Object.create(null); for (const t in e) n[t] = e[t]; return t.forEach((function (e) { for (const t in e) n[t] = e[t] })), n } const a = e => !!e.kind; class o { constructor(e, t) { this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this) } addText(e) { this.buffer += i(e) } openNode(e) { if (!a(e)) return; let t = e.kind; t = e.sublanguage ? `language-${t}` : ((e, { prefix: t }) => { if (e.includes(".")) { const n = e.split("."); return [`${t}${n.shift()}`, ...n.map(((e, t) => `${e}${"_".repeat(t + 1)}`))].join(" ") } return `${t}${e}` })(t, { prefix: this.classPrefix }), this.span(t) } closeNode(e) { a(e) && (this.buffer += "</span>") } value() { return this.buffer } span(e) { this.buffer += `<span class="${e}">` } } class l { constructor() { this.rootNode = { children: [] }, this.stack = [this.rootNode] } get top() { return this.stack[this.stack.length - 1] } get root() { return this.rootNode } add(e) { this.top.children.push(e) } openNode(e) { const t = { kind: e, children: [] }; this.add(t), this.stack.push(t) } closeNode() { if (this.stack.length > 1) return this.stack.pop() } closeAllNodes() { for (; this.closeNode();); } toJSON() { return JSON.stringify(this.rootNode, null, 4) } walk(e) { return this.constructor._walk(e, this.rootNode) } static _walk(e, t) { return "string" == typeof t ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((t => this._walk(e, t))), e.closeNode(t)), e } static _collapse(e) { "string" != typeof e && e.children && (e.children.every((e => "string" == typeof e)) ? e.children = [e.children.join("")] : e.children.forEach((e => { l._collapse(e) }))) } } class c extends l { constructor(e) { super(), this.options = e } addKeyword(e, t) { "" !== e && (this.openNode(t), this.addText(e), this.closeNode()) } addText(e) { "" !== e && this.add(e) } addSublanguage(e, t) { const n = e.root; n.kind = t, n.sublanguage = !0, this.add(n) } toHTML() { return new o(this, this.options).value() } finalize() { return !0 } } function h(e) { return e ? "string" == typeof e ? e : e.source : null } function D(...e) { return e.map((e => h(e))).join("") } function g(...e) { const t = function (e) { const t = e[e.length - 1]; return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {} }(e); return "(" + (t.capture ? "" : "?:") + e.map((e => h(e))).join("|") + ")" } function p(e) { return new RegExp(e.toString() + "|").exec("").length - 1 } const d = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./; function f(e, { joinWith: t }) { let n = 0; return e.map((e => { n += 1; const t = n; let u = h(e), r = ""; for (; u.length > 0;) { const e = d.exec(u); if (!e) { r += u; break } r += u.substring(0, e.index), u = u.substring(e.index + e[0].length), "\\" === e[0][0] && e[1] ? r += "\\" + String(Number(e[1]) + t) : (r += e[0], "(" === e[0] && n++) } return r })).map((e => `(${e})`)).join(t) } const b = "[a-zA-Z]\\w*", A = "[a-zA-Z_]\\w*", E = "\\b\\d+(\\.\\d+)?", x = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", m = "\\b(0b[01]+)", k = { begin: "\\\\[\\s\\S]", relevance: 0 }, F = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [k] }, C = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [k] }, w = function (e, t, n = {}) { const u = s({ scope: "comment", begin: e, end: t, contains: [] }, n); u.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: !0, relevance: 0 }); const r = g("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/); return u.contains.push({ begin: D(/[ ]+/, "(", r, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), u }, B = w("//", "$"), v = w("/\\*", "\\*/"), y = w("#", "$"), _ = { scope: "number", begin: E, relevance: 0 }, S = { scope: "number", begin: x, relevance: 0 }, R = { scope: "number", begin: m, relevance: 0 }, z = { begin: /(?=\/[^/\n]*\/)/, contains: [{ scope: "regexp", begin: /\//, end: /\/[gimuy]*/, illegal: /\n/, contains: [k, { begin: /\[/, end: /\]/, relevance: 0, contains: [k] }] }] }, $ = { scope: "title", begin: b, relevance: 0 }, O = { scope: "title", begin: A, relevance: 0 }; var T = Object.freeze({ __proto__: null, MATCH_NOTHING_RE: /\b\B/, IDENT_RE: b, UNDERSCORE_IDENT_RE: A, NUMBER_RE: E, C_NUMBER_RE: x, BINARY_NUMBER_RE: m, RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", SHEBANG: (e = {}) => { const t = /^#![ ]*\//; return e.binary && (e.begin = D(t, /.*\b/, e.binary, /\b.*/)), s({ scope: "meta", begin: t, end: /$/, relevance: 0, "on:begin": (e, t) => { 0 !== e.index && t.ignoreMatch() } }, e) }, BACKSLASH_ESCAPE: k, APOS_STRING_MODE: F, QUOTE_STRING_MODE: C, PHRASAL_WORDS_MODE: { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, COMMENT: w, C_LINE_COMMENT_MODE: B, C_BLOCK_COMMENT_MODE: v, HASH_COMMENT_MODE: y, NUMBER_MODE: _, C_NUMBER_MODE: S, BINARY_NUMBER_MODE: R, REGEXP_MODE: z, TITLE_MODE: $, UNDERSCORE_TITLE_MODE: O, METHOD_GUARD: { begin: "\\.\\s*[a-zA-Z_]\\w*", relevance: 0 }, END_SAME_AS_BEGIN: function (e) { return Object.assign(e, { "on:begin": (e, t) => { t.data._beginMatch = e[1] }, "on:end": (e, t) => { t.data._beginMatch !== e[1] && t.ignoreMatch() } }) } }); function I(e, t) { "." === e.input[e.index - 1] && t.ignoreMatch() } function N(e, t) { void 0 !== e.className && (e.scope = e.className, delete e.className) } function j(e, t) { t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = I, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, void 0 === e.relevance && (e.relevance = 0)) } function M(e, t) { Array.isArray(e.illegal) && (e.illegal = g(...e.illegal)) } function L(e, t) { if (e.match) { if (e.begin || e.end) throw new Error("begin & end are not supported with match"); e.begin = e.match, delete e.match } } function P(e, t) { void 0 === e.relevance && (e.relevance = 1) } const Z = (e, t) => { if (!e.beforeMatch) return; if (e.starts) throw new Error("beforeMatch cannot be used with starts"); const n = Object.assign({}, e); Object.keys(e).forEach((t => { delete e[t] })), e.keywords = n.keywords, e.begin = D(n.beforeMatch, D("(?=", n.begin, ")")), e.starts = { relevance: 0, contains: [Object.assign(n, { endsParent: !0 })] }, e.relevance = 0, delete n.beforeMatch }, U = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"]; function H(e, t, n = "keyword") { const u = Object.create(null); return "string" == typeof e ? r(n, e.split(" ")) : Array.isArray(e) ? r(n, e) : Object.keys(e).forEach((function (n) { Object.assign(u, H(e[n], t, n)) })), u; function r(e, n) { t && (n = n.map((e => e.toLowerCase()))), n.forEach((function (t) { const n = t.split("|"); u[n[0]] = [e, q(n[0], n[1])] })) } } function q(e, t) { return t ? Number(t) : function (e) { return U.includes(e.toLowerCase()) }(e) ? 0 : 1 } const K = {}, X = e => { console.error(e) }, G = (e, ...t) => { console.log(`WARN: ${e}`, ...t) }, Q = (e, t) => { K[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`), K[`${e}/${t}`] = !0) }, W = new Error; function J(e, t, { key: n }) { let u = 0; const r = e[n], i = {}, s = {}; for (let e = 1; e <= t.length; e++)s[e + u] = r[e], i[e + u] = !0, u += p(t[e - 1]); e[n] = s, e[n]._emit = i, e[n]._multi = !0 } function V(e) { !function (e) { e.scope && "object" == typeof e.scope && null !== e.scope && (e.beginScope = e.scope, delete e.scope) }(e), "string" == typeof e.beginScope && (e.beginScope = { _wrap: e.beginScope }), "string" == typeof e.endScope && (e.endScope = { _wrap: e.endScope }), function (e) { if (Array.isArray(e.begin)) { if (e.skip || e.excludeBegin || e.returnBegin) throw X("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), W; if ("object" != typeof e.beginScope || null === e.beginScope) throw X("beginScope must be object"), W; J(e, e.begin, { key: "beginScope" }), e.begin = f(e.begin, { joinWith: "" }) } }(e), function (e) { if (Array.isArray(e.end)) { if (e.skip || e.excludeEnd || e.returnEnd) throw X("skip, excludeEnd, returnEnd not compatible with endScope: {}"), W; if ("object" != typeof e.endScope || null === e.endScope) throw X("endScope must be object"), W; J(e, e.end, { key: "endScope" }), e.end = f(e.end, { joinWith: "" }) } }(e) } function Y(e) { function t(t, n) { return new RegExp(h(t), "m" + (e.case_insensitive ? "i" : "") + (n ? "g" : "")) } class n { constructor() { this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0 } addRule(e, t) { t.position = this.position++, this.matchIndexes[this.matchAt] = t, this.regexes.push([t, e]), this.matchAt += p(e) + 1 } compile() { 0 === this.regexes.length && (this.exec = () => null); const e = this.regexes.map((e => e[1])); this.matcherRe = t(f(e, { joinWith: "|" }), !0), this.lastIndex = 0 } exec(e) { this.matcherRe.lastIndex = this.lastIndex; const t = this.matcherRe.exec(e); if (!t) return null; const n = t.findIndex(((e, t) => t > 0 && void 0 !== e)), u = this.matchIndexes[n]; return t.splice(0, n), Object.assign(t, u) } } class u { constructor() { this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0 } getMatcher(e) { if (this.multiRegexes[e]) return this.multiRegexes[e]; const t = new n; return this.rules.slice(e).forEach((([e, n]) => t.addRule(e, n))), t.compile(), this.multiRegexes[e] = t, t } resumingScanAtSamePosition() { return 0 !== this.regexIndex } considerAll() { this.regexIndex = 0 } addRule(e, t) { this.rules.push([e, t]), "begin" === t.type && this.count++ } exec(e) { const t = this.getMatcher(this.regexIndex); t.lastIndex = this.lastIndex; let n = t.exec(e); if (this.resumingScanAtSamePosition()) if (n && n.index === this.lastIndex); else { const t = this.getMatcher(0); t.lastIndex = this.lastIndex + 1, n = t.exec(e) } return n && (this.regexIndex += n.position + 1, this.regexIndex === this.count && this.considerAll()), n } } if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self")) throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation."); return e.classNameAliases = s(e.classNameAliases || {}), function n(r, i) { const a = r; if (r.isCompiled) return a;[N, L, V, Z].forEach((e => e(r, i))), e.compilerExtensions.forEach((e => e(r, i))), r.__beforeBegin = null, [j, M, P].forEach((e => e(r, i))), r.isCompiled = !0; let o = null; return "object" == typeof r.keywords && r.keywords.$pattern && (r.keywords = Object.assign({}, r.keywords), o = r.keywords.$pattern, delete r.keywords.$pattern), o = o || /\w+/, r.keywords && (r.keywords = H(r.keywords, e.case_insensitive)), a.keywordPatternRe = t(o, !0), i && (r.begin || (r.begin = /\B|\b/), a.beginRe = t(r.begin), r.end || r.endsWithParent || (r.end = /\B|\b/), r.end && (a.endRe = t(r.end)), a.terminatorEnd = h(r.end) || "", r.endsWithParent && i.terminatorEnd && (a.terminatorEnd += (r.end ? "|" : "") + i.terminatorEnd)), r.illegal && (a.illegalRe = t(r.illegal)), r.contains || (r.contains = []), r.contains = [].concat(...r.contains.map((function (e) { return function (e) { return e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map((function (t) { return s(e, { variants: null }, t) }))), e.cachedVariants ? e.cachedVariants : ee(e) ? s(e, { starts: e.starts ? s(e.starts) : null }) : Object.isFrozen(e) ? s(e) : e }("self" === e ? r : e) }))), r.contains.forEach((function (e) { n(e, a) })), r.starts && n(r.starts, i), a.matcher = function (e) { const t = new u; return e.contains.forEach((e => t.addRule(e.begin, { rule: e, type: "begin" }))), e.terminatorEnd && t.addRule(e.terminatorEnd, { type: "end" }), e.illegal && t.addRule(e.illegal, { type: "illegal" }), t }(a), a }(e) } function ee(e) { return !!e && (e.endsWithParent || ee(e.starts)) } const te = i, ne = s, ue = Symbol("nomatch"); var re = function (e) { const t = Object.create(null), n = Object.create(null), i = []; let s = !0; const a = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] }; let l = { ignoreUnescapedHTML: !1, noHighlightRe: /^(no-?highlight)$/i, languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-", cssSelector: "pre code", languages: null, __emitter: c }; function h(e) { return l.noHighlightRe.test(e) } function D(e, t, n) { let u = "", r = ""; "object" == typeof t ? (u = e, n = t.ignoreIllegals, r = t.language) : (Q("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Q("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"), r = e, u = t), void 0 === n && (n = !0); const i = { code: u, language: r }; m("before:highlight", i); const s = i.result ? i.result : g(i.language, i.code, n); return s.code = i.code, m("after:highlight", s), s } function g(e, n, u, i) { const o = Object.create(null); function c() { if (!w.keywords) return void v.addText(y); let e = 0; w.keywordPatternRe.lastIndex = 0; let t = w.keywordPatternRe.exec(y), n = ""; for (; t;) { n += y.substring(e, t.index); const r = k.case_insensitive ? t[0].toLowerCase() : t[0], i = (u = r, w.keywords[u]); if (i) { const [e, u] = i; if (v.addText(n), n = "", o[r] = (o[r] || 0) + 1, o[r] <= 7 && (_ += u), e.startsWith("_")) n += t[0]; else { const n = k.classNameAliases[e] || e; v.addKeyword(t[0], n) } } else n += t[0]; e = w.keywordPatternRe.lastIndex, t = w.keywordPatternRe.exec(y) } var u; n += y.substr(e), v.addText(n) } function h() { null != w.subLanguage ? function () { if ("" === y) return; let e = null; if ("string" == typeof w.subLanguage) { if (!t[w.subLanguage]) return void v.addText(y); e = g(w.subLanguage, y, !0, B[w.subLanguage]), B[w.subLanguage] = e._top } else e = p(y, w.subLanguage.length ? w.subLanguage : null); w.relevance > 0 && (_ += e.relevance), v.addSublanguage(e._emitter, e.language) }() : c(), y = "" } function D(e, t) { let n = 1; for (; void 0 !== t[n];) { if (!e._emit[n]) { n++; continue } const u = k.classNameAliases[e[n]] || e[n], r = t[n]; u ? v.addKeyword(r, u) : (y = r, c(), y = ""), n++ } } function d(e, t) { return e.scope && "string" == typeof e.scope && v.openNode(k.classNameAliases[e.scope] || e.scope), e.beginScope && (e.beginScope._wrap ? (v.addKeyword(y, k.classNameAliases[e.beginScope._wrap] || e.beginScope._wrap), y = "") : e.beginScope._multi && (D(e.beginScope, t), y = "")), w = Object.create(e, { parent: { value: w } }), w } function f(e, t, n) { let u = function (e, t) { const n = e && e.exec(t); return n && 0 === n.index }(e.endRe, n); if (u) { if (e["on:end"]) { const n = new r(e); e["on:end"](t, n), n.isMatchIgnored && (u = !1) } if (u) { for (; e.endsParent && e.parent;)e = e.parent; return e } } if (e.endsWithParent) return f(e.parent, t, n) } function b(e) { return 0 === w.matcher.regexIndex ? (y += e[0], 1) : (z = !0, 0) } function E(e) { const t = e[0], u = n.substr(e.index), r = f(w, e, u); if (!r) return ue; const i = w; w.endScope && w.endScope._wrap ? (h(), v.addKeyword(t, w.endScope._wrap)) : w.endScope && w.endScope._multi ? (h(), D(w.endScope, e)) : i.skip ? y += t : (i.returnEnd || i.excludeEnd || (y += t), h(), i.excludeEnd && (y = t)); do { w.scope && v.closeNode(), w.skip || w.subLanguage || (_ += w.relevance), w = w.parent } while (w !== r.parent); return r.starts && d(r.starts, e), i.returnEnd ? 0 : t.length } let x = {}; function m(t, i) { const a = i && i[0]; if (y += t, null == a) return h(), 0; if ("begin" === x.type && "end" === i.type && x.index === i.index && "" === a) { if (y += n.slice(i.index, i.index + 1), !s) { const t = new Error(`0 width match regex (${e})`); throw t.languageName = e, t.badRule = x.rule, t } return 1 } if (x = i, "begin" === i.type) return function (e) { const t = e[0], n = e.rule, u = new r(n), i = [n.__beforeBegin, n["on:begin"]]; for (const n of i) if (n && (n(e, u), u.isMatchIgnored)) return b(t); return n.skip ? y += t : (n.excludeBegin && (y += t), h(), n.returnBegin || n.excludeBegin || (y = t)), d(n, e), n.returnBegin ? 0 : t.length }(i); if ("illegal" === i.type && !u) { const e = new Error('Illegal lexeme "' + a + '" for mode "' + (w.scope || "<unnamed>") + '"'); throw e.mode = w, e } if ("end" === i.type) { const e = E(i); if (e !== ue) return e } if ("illegal" === i.type && "" === a) return 1; if (R > 1e5 && R > 3 * i.index) throw new Error("potential infinite loop, way more iterations than matches"); return y += a, a.length } const k = A(e); if (!k) throw X(a.replace("{}", e)), new Error('Unknown language: "' + e + '"'); const F = Y(k); let C = "", w = i || F; const B = {}, v = new l.__emitter(l); !function () { const e = []; for (let t = w; t !== k; t = t.parent)t.scope && e.unshift(t.scope); e.forEach((e => v.openNode(e))) }(); let y = "", _ = 0, S = 0, R = 0, z = !1; try { for (w.matcher.considerAll(); ;) { R++, z ? z = !1 : w.matcher.considerAll(), w.matcher.lastIndex = S; const e = w.matcher.exec(n); if (!e) break; const t = m(n.substring(S, e.index), e); S = e.index + t } return m(n.substr(S)), v.closeAllNodes(), v.finalize(), C = v.toHTML(), { language: e, value: C, relevance: _, illegal: !1, _emitter: v, _top: w } } catch (t) { if (t.message && t.message.includes("Illegal")) return { language: e, value: te(n), illegal: !0, relevance: 0, _illegalBy: { message: t.message, index: S, context: n.slice(S - 100, S + 100), mode: t.mode, resultSoFar: C }, _emitter: v }; if (s) return { language: e, value: te(n), illegal: !1, relevance: 0, errorRaised: t, _emitter: v, _top: w }; throw t } } function p(e, n) { n = n || l.languages || Object.keys(t); const u = function (e) { const t = { value: te(e), illegal: !1, relevance: 0, _top: o, _emitter: new l.__emitter(l) }; return t._emitter.addText(e), t }(e), r = n.filter(A).filter(x).map((t => g(t, e, !1))); r.unshift(u); const i = r.sort(((e, t) => { if (e.relevance !== t.relevance) return t.relevance - e.relevance; if (e.language && t.language) { if (A(e.language).supersetOf === t.language) return 1; if (A(t.language).supersetOf === e.language) return -1 } return 0 })), [s, a] = i, c = s; return c.secondBest = a, c } function d(e) { let t = null; const u = function (e) { let t = e.className + " "; t += e.parentNode ? e.parentNode.className : ""; const n = l.languageDetectRe.exec(t); if (n) { const t = A(n[1]); return t || (G(a.replace("{}", n[1])), G("Falling back to no-highlight mode for this block.", e)), t ? n[1] : "no-highlight" } return t.split(/\s+/).find((e => h(e) || A(e))) }(e); if (h(u)) return; m("before:highlightElement", { el: e, language: u }), !l.ignoreUnescapedHTML && e.children.length > 0 && (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/issues/2886"), console.warn(e)), t = e; const r = t.textContent, i = u ? D(r, { language: u, ignoreIllegals: !0 }) : p(r); e.innerHTML = i.value, function (e, t, u) { const r = t && n[t] || u; e.classList.add("hljs"), e.classList.add(`language-${r}`) }(e, u, i.language), e.result = { language: i.language, re: i.relevance, relevance: i.relevance }, i.secondBest && (e.secondBest = { language: i.secondBest.language, relevance: i.secondBest.relevance }), m("after:highlightElement", { el: e, result: i, text: r }) } let f = !1; function b() { "loading" !== document.readyState ? document.querySelectorAll(l.cssSelector).forEach(d) : f = !0 } function A(e) { return e = (e || "").toLowerCase(), t[e] || t[n[e]] } function E(e, { languageName: t }) { "string" == typeof e && (e = [e]), e.forEach((e => { n[e.toLowerCase()] = t })) } function x(e) { const t = A(e); return t && !t.disableAutodetect } function m(e, t) { const n = e; i.forEach((function (e) { e[n] && e[n](t) })) } "undefined" != typeof window && window.addEventListener && window.addEventListener("DOMContentLoaded", (function () { f && b() }), !1), Object.assign(e, { highlight: D, highlightAuto: p, highlightAll: b, highlightElement: d, highlightBlock: function (e) { return Q("10.7.0", "highlightBlock will be removed entirely in v12.0"), Q("10.7.0", "Please use highlightElement now."), d(e) }, configure: function (e) { l = ne(l, e) }, initHighlighting: () => { b(), Q("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.") }, initHighlightingOnLoad: function () { b(), Q("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.") }, registerLanguage: function (n, u) { let r = null; try { r = u(e) } catch (e) { if (X("Language definition for '{}' could not be registered.".replace("{}", n)), !s) throw e; X(e), r = o } r.name || (r.name = n), t[n] = r, r.rawDefinition = u.bind(null, e), r.aliases && E(r.aliases, { languageName: n }) }, unregisterLanguage: function (e) { delete t[e]; for (const t of Object.keys(n)) n[t] === e && delete n[t] }, listLanguages: function () { return Object.keys(t) }, getLanguage: A, registerAliases: E, autoDetection: x, inherit: ne, addPlugin: function (e) { !function (e) { e["before:highlightBlock"] && !e["before:highlightElement"] && (e["before:highlightElement"] = t => { e["before:highlightBlock"](Object.assign({ block: t.el }, t)) }), e["after:highlightBlock"] && !e["after:highlightElement"] && (e["after:highlightElement"] = t => { e["after:highlightBlock"](Object.assign({ block: t.el }, t)) }) }(e), i.push(e) } }), e.debugMode = function () { s = !1 }, e.safeMode = function () { s = !0 }, e.versionString = "11.2.0"; for (const e in T) "object" == typeof T[e] && u(T[e]); return Object.assign(e, T), e }({}); e.exports = re }, 245: e => { function t(e) { return e ? "string" == typeof e ? e : e.source : null } function n(...e) { return e.map((e => t(e))).join("") } const u = "[a-zA-Z_]\\w*", r = function (e, u, r = {}) { const i = function (e, ...t) { const n = Object.create(null); for (const t in e) n[t] = e[t]; return t.forEach((function (e) { for (const t in e) n[t] = e[t] })), n }({ scope: "comment", begin: e, end: u, contains: [] }, r); i.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: !0, relevance: 0 }); const s = function (...e) { const n = function (e) { const t = e[e.length - 1]; return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {} }(e); return "(" + (n.capture ? "" : "?:") + e.map((e => t(e))).join("|") + ")" }("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/); return i.contains.push({ begin: n(/[ ]+/, "(", s, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), i }; r("//", "$"), r("/\\*", "\\*/"), r("#", "$"), e.exports = function (e) { const t = { $pattern: /[A-Za-z]\w+|__\w+__/, keyword: ["and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"], built_in: ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"], literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"], type: ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"] }, r = { className: "meta", begin: /^(>>>|\.\.\.) / }, i = { className: "subst", begin: /\{/, end: /\}/, keywords: t, illegal: /#/ }, s = { begin: /\{\{/, relevance: 0 }, a = { className: "string", contains: [e.BACKSLASH_ESCAPE], variants: [{ begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/, end: /'''/, contains: [e.BACKSLASH_ESCAPE, r], relevance: 10 }, { begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/, end: /"""/, contains: [e.BACKSLASH_ESCAPE, r], relevance: 10 }, { begin: /([fF][rR]|[rR][fF]|[fF])'''/, end: /'''/, contains: [e.BACKSLASH_ESCAPE, r, s, i] }, { begin: /([fF][rR]|[rR][fF]|[fF])"""/, end: /"""/, contains: [e.BACKSLASH_ESCAPE, r, s, i] }, { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 }, { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 }, { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ }, { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ }, { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [e.BACKSLASH_ESCAPE, s, i] }, { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, s, i] }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE] }, o = "[0-9](_?[0-9])*", l = `(\\b(${o}))?\\.(${o})|\\b(${o})\\.`, c = { className: "number", relevance: 0, variants: [{ begin: `(\\b(${o})|(${l}))[eE][+-]?(${o})[jJ]?\\b` }, { begin: `(${l})[jJ]?` }, { begin: "\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\b" }, { begin: "\\b0[bB](_?[01])+[lL]?\\b" }, { begin: "\\b0[oO](_?[0-7])+[lL]?\\b" }, { begin: "\\b0[xX](_?[0-9a-fA-F])+[lL]?\\b" }, { begin: `\\b(${o})[jJ]\\b` }] }, h = { className: "comment", begin: (D = /# type:/, n("(?=", D, ")")), end: /$/, keywords: t, contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: !0 }] }; var D; const g = { className: "params", variants: [{ className: "", begin: /\(\s*\)/, skip: !0 }, { begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: t, contains: ["self", r, c, a, e.HASH_COMMENT_MODE] }] }; return i.contains = [a, c, r], { name: "Python", aliases: ["py", "gyp", "ipython"], keywords: t, illegal: /(<\/|->|\?)|=>/, contains: [r, c, { begin: /\bself\b/ }, { beginKeywords: "if", relevance: 0 }, a, h, e.HASH_COMMENT_MODE, { match: [/def/, /\s+/, u], scope: { 1: "keyword", 3: "title.function" }, contains: [g] }, { variants: [{ match: [/class/, /\s+/, u, /\s*/, /\(\s*/, u, /\s*\)/] }, { match: [/class/, /\s+/, u] }], scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" } }, { className: "meta", begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [c, g, a] }] } } } }, t = {}; function n(u) { var r = t[u]; if (void 0 !== r) return r.exports; var i = t[u] = { exports: {} }; return e[u].call(i.exports, i, i.exports, n), i.exports } (() => { const e = n(390); e.registerLanguage("python", n(245)), globalThis.hljs = e; const t = n(84); globalThis.marked = t })() })();

const style = document.createElement("style");
style.innerHTML =
    // for pandas DaraFrame table
    `
    table.dataframe{
        border-collapse: collapse;
        border: none;
        border-color: transparent;
    }
    .dataframe thead{
        border-bottom: 1px solid gray;
    }
    .dataframe th, 
    .dataframe tr, 
    .dataframe td{
        text-align: right;
        padding: 0.5em 0.5em;
    }
    .dataframe tbody tr:nth-child(odd) {
        background: whitesmoke;
    }
    .dataframe tbody tr:hover {
        background: paleturquoise;
    }`;
document.head.appendChild(style);

export class IpynbViewer extends HTMLElement {
    static dataMap = new Map();
    async connectedCallback() {
        this.style.display = "block";

        if (!"nb" in this.dataset) {
            console.log("notebook is not specified as 'data-nb' attribute.");
            return;
        }

        if (!customElements.get("nb-cell")) {
            customElements.define("nb-cell", NbCell);
        }

        if (!this.constructor.dataMap.has(this.dataset.nb)) {
            this.constructor.dataMap.set(
                this.dataset.nb,
                fetch(this.dataset.nb).then(res => res.json())
            );
        }

        this.nb = await this.constructor.dataMap.get(this.dataset.nb);

        if ("index" in this.dataset) {
            this.cells = [...this.dataset.index.matchAll(/(?<i>\d+),?/g)].map(m => this.nb.cells[Number(m.groups.i)]);
        } else if ("slice" in this.dataset) {
            this.cells = Function(`return this.nb.cells.slice(${this.dataset.slice})`).bind(this)();
        } else {
            this.cells = this.nb.cells;
        }

        this.cells.forEach(cell => {
            const nbCell = document.createElement("nb-cell");
            nbCell.init(cell);
            this.appendChild(nbCell);
        })
    }
}

class NbCell extends HTMLElement {
    connectedCallback() {
        this.style.display = "block";
    }
    init(cell) {
        const shadow = this.attachShadow({ mode: 'closed' });
        shadow.innerHTML = `
            <style>
                #out-container{
                    overflow: auto;
                    font-size: 0.7rem;
                    margin: 1rem;
                }
            </style>
            <div id="src-container">
                <slot name="src"></slot>
            </div>
            <div id="out-container">
                <slot name="out"></slot>
            </div>
        `
        this.innerHTML = `
            <div data-role="src" slot="src"></div>
            <div data-role="out" slot="out"></div>
        `;
        this.querySelectorAll("[data-role]").forEach(elm => {
            this[elm.dataset.role] = elm;
        });
        this.cellData = cell;
        this.renderSrc(cell.source);
        this.renderOut(cell.outputs);
    }
    renderSrc(src) {
        let srcHTML;
        if (this.cellData.cell_type === "markdown") {
            srcHTML = marked(src.join(""));
        } else if (this.cellData.cell_type === "code") {
            ({ value: srcHTML } = hljs.highlight(src.join(""), { language: "py" }));
            srcHTML = `<pre style="margin:0;"><code class="lang-py hljs">${srcHTML}</code></pre>`;
        }

        this.src.innerHTML = srcHTML;
    }
    renderOut(outs) {
        if (outs === undefined || outs.length === 0) return;

        for (const out of outs) {
            if (out.output_type === "stream") {
                this.out.innerHTML = out.text.join("");
                this.out.style.whiteSpace = "pre";
                return;
            } else {
                if (!"data" in out) continue;

                if ("text/html" in out.data) {
                    this.out.appendChild(this.strToElm(out.data["text/html"].join("")));
                } else if ("image/png" in out.data) {
                    this.outImg = document.createElement("img");
                    Object.entries({
                        maxWidth: "100%",
                        display: "block"
                    }).forEach(([key, val]) => this.outImg.style[key] = val);
                    this.outImg.src = `data:image/png;base64,${out.data["image/png"]}`

                    this.out.appendChild(this.outImg);
                } else if ("text/plain" in out.data) {
                    this.out.insertAdjacentText("beforeend", out.data["text/plain"].join(""));
                } else if ("application/javascript" in out.data) {
                    const s = document.createElement("script");
                    s.innerHTML = out.data["application/javascript"].join("");
                    this.out.appendChild(s);
                }
            }
        }
    }

    strToElm(str) {
        const container = document.createElement("div");
        container.innerHTML = str
            .replaceAll(/<\/?html.*?>/g, "")
            .replaceAll(/<\/?head.*?>/g, "")
            .replaceAll(/<meta.*?>/g, "")
            .replaceAll(/<title>.*<\/title>/g, "");

        let outerScriptId = '';
        container.querySelectorAll("script").forEach(s => {
            const newScript = document.createElement("script");

            for (let i = 0; i < s.attributes.length; i++)
                newScript.setAttribute(s.attributes[i].name, s.attributes[i].value);

            if (newScript.hasAttribute("src")) {
                outerScriptId = String(Math.random()).slice(2);
                newScript.setAttribute("id", outerScriptId);
            } else if (outerScriptId && newScript.type !== 'application/json') {
                newScript.innerHTML = `
                    document.getElementById('${outerScriptId}')
                    .addEventListener('load', ()=>{${s.innerText}})`;
            } else {
                newScript.innerHTML = s.innerText;
            }

            s.replaceWith(newScript);
        })
        return container
    }
}